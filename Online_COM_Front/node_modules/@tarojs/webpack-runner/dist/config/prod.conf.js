"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("@tarojs/helper");
const shared_1 = require("@tarojs/shared");
const lodash_1 = require("lodash");
const path = require("path");
const utils_1 = require("../utils");
const chain_1 = require("../utils/chain");
const component_1 = require("../utils/component");
const base_conf_1 = require("./base.conf");
function default_1(appPath, config, appHelper) {
    var _a;
    const chain = (0, base_conf_1.default)(appPath, config);
    const { alias = {}, copy, entry = {}, entryFileName = 'app', output = {}, sourceRoot = '', outputRoot = 'dist', publicPath = '/', staticDirectory = 'static', chunkDirectory = 'chunk', router = {}, designWidth = 750, deviceRatio, enableSourceMap = false, sourceMapType, enableExtract = true, defineConstants = {}, env = {}, styleLoaderOption = {}, cssLoaderOption = {}, sassLoaderOption = {}, lessLoaderOption = {}, stylusLoaderOption = {}, mediaUrlLoaderOption = {}, fontUrlLoaderOption = {}, imageUrlLoaderOption = {}, miniCssExtractPluginOption = {}, esnextModules = [], compile = {}, postcss = {}, htmlPluginOption = {}, csso, uglify, terser, buildAdapter = helper_1.PLATFORMS.H5, framework = 'react', useDeprecatedAdapterComponent = false } = config;
    const sourceDir = path.join(appPath, sourceRoot);
    const isMultiRouterMode = (0, lodash_1.get)(router, 'mode') === 'multi';
    const { rule, postcssOption } = (0, chain_1.parseModule)(appPath, {
        designWidth,
        deviceRatio,
        enableExtract,
        enableSourceMap,
        styleLoaderOption,
        cssLoaderOption,
        lessLoaderOption,
        sassLoaderOption,
        stylusLoaderOption,
        fontUrlLoaderOption,
        imageUrlLoaderOption,
        mediaUrlLoaderOption,
        esnextModules,
        compile,
        postcss,
        sourceDir,
        staticDirectory
    });
    const [, pxtransformOption] = postcssOption.find(([name]) => name === 'postcss-pxtransform') || [];
    const plugin = {};
    plugin.mainPlugin = (0, chain_1.getMainPlugin)({
        /** paths */
        sourceDir,
        entryFileName,
        /** config & message */
        framework: config.framework,
        frameworkExts: config.frameworkExts,
        routerConfig: router,
        runtimePath: config.runtimePath,
        pxTransformConfig: (pxtransformOption === null || pxtransformOption === void 0 ? void 0 : pxtransformOption.config) || {},
        /** building mode */
        isBuildNativeComp: config.isBuildNativeComp,
        /** hooks & methods */
        onCompilerMake: config.onCompilerMake,
        onParseCreateElement: config.onParseCreateElement,
    });
    if (enableExtract) {
        plugin.miniCssExtractPlugin = (0, chain_1.getMiniCssExtractPlugin)([
            {
                filename: 'css/[name].css',
                chunkFilename: 'css/[name].css'
            },
            miniCssExtractPluginOption
        ]);
    }
    if (copy) {
        plugin.copyWebpackPlugin = (0, chain_1.getCopyWebpackPlugin)({ copy, appPath });
    }
    const htmlScript = (0, utils_1.parseHtmlScript)(pxtransformOption);
    if (process.env.NODE_ENV !== 'production' && htmlScript !== undefined && Object.hasOwnProperty.call(htmlPluginOption, 'script')) {
        console.warn(helper_1.chalk.yellowBright('配置文件覆盖 htmlPluginOption.script 参数会导致 pxtransform 脚本失效，请慎重使用！'));
    }
    const template = path.join(sourceDir, 'index.html');
    if (helper_1.fs.existsSync(template)) {
        if (isMultiRouterMode) {
            delete entry[entryFileName];
            appHelper.pagesConfigList.forEach((page, index) => {
                entry[index] = [page];
            });
            (0, lodash_1.merge)(plugin, (0, lodash_1.mapValues)(entry, (_filePath, entryName) => {
                return (0, chain_1.getHtmlWebpackPlugin)([(0, helper_1.recursiveMerge)({
                        filename: `${entryName}.html`,
                        script: htmlScript,
                        template,
                        chunks: [entryName]
                    }, htmlPluginOption)]);
            }));
        }
        else {
            plugin.htmlWebpackPlugin = (0, chain_1.getHtmlWebpackPlugin)([(0, helper_1.recursiveMerge)({
                    filename: 'index.html',
                    script: htmlScript,
                    template,
                }, htmlPluginOption)]);
        }
    }
    env.FRAMEWORK = JSON.stringify(framework);
    env.TARO_ENV = JSON.stringify(buildAdapter);
    env.TARO_PLATFORM = JSON.stringify(process.env.TARO_PLATFORM || shared_1.PLATFORM_TYPE.WEB);
    env.SUPPORT_TARO_POLYFILL = env.SUPPORT_TARO_POLYFILL || '"enabled"';
    env.SUPPORT_DINGTALK_NAVIGATE = env.SUPPORT_DINGTALK_NAVIGATE || '"disabled"';
    defineConstants.DEPRECATED_ADAPTER_COMPONENT = JSON.stringify(!!useDeprecatedAdapterComponent);
    plugin.definePlugin = (0, chain_1.getDefinePlugin)([(0, chain_1.processEnvOption)(env), defineConstants]);
    const isCssoEnabled = !(csso && csso.enable === false);
    if (isCssoEnabled) {
        plugin.cssoWebpackPlugin = (0, chain_1.getCssoWebpackPlugin)([csso ? csso.config : {}]);
    }
    const mode = 'production';
    const minimizer = [];
    const uglifyConfig = uglify || terser;
    const isUglifyEnabled = !(uglifyConfig && uglifyConfig.enable === false);
    if (isUglifyEnabled) {
        minimizer.push((0, chain_1.getTerserPlugin)([
            enableSourceMap,
            uglifyConfig ? uglifyConfig.config : {}
        ]));
    }
    const webpackOutput = (0, chain_1.getOutput)(appPath, [{
            outputRoot,
            publicPath: ['', 'auto'].includes(publicPath) ? publicPath : (0, utils_1.addTrailingSlash)(publicPath),
            chunkDirectory
        }, output]);
    (_a = config.modifyComponentConfig) === null || _a === void 0 ? void 0 : _a.call(config, component_1.componentConfig, config);
    if (config.isBuildNativeComp) {
        // Note: 当开发者没有配置时，优先使用 module 导出组件
        webpackOutput.libraryTarget || (webpackOutput.libraryTarget = 'commonjs');
    }
    chain.merge({
        mode,
        devtool: (0, chain_1.getDevtool)({ enableSourceMap, sourceMapType }),
        entry,
        output: webpackOutput,
        resolve: { alias },
        module: { rule },
        plugin,
        optimization: {
            minimizer,
            splitChunks: {
                name: false,
                chunks: 'initial',
                minSize: 0,
                cacheGroups: {
                    default: false,
                    common: {
                        name: false,
                        minChunks: 2,
                        priority: 1
                    },
                    vendors: {
                        name: false,
                        minChunks: 2,
                        test: module => /[\\/]node_modules[\\/]/.test(module.resource),
                        priority: 10
                    },
                    taro: {
                        name: false,
                        test: module => /@tarojs[\\/][a-z]+/.test(module.context),
                        priority: 100
                    }
                }
            }
        }
    });
    return chain;
}
exports.default = default_1;
//# sourceMappingURL=prod.conf.js.map