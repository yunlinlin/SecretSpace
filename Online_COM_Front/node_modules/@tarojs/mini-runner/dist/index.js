"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("@tarojs/helper");
const lodash_1 = require("lodash");
const webpack = require("webpack");
const prerender_1 = require("./prerender/prerender");
const component_1 = require("./template/component");
const logHelper_1 = require("./utils/logHelper");
const build_conf_1 = require("./webpack/build.conf");
const chain_1 = require("./webpack/chain");
const customizeChain = (chain, modifyWebpackChainFunc, customizeFunc) => __awaiter(void 0, void 0, void 0, function* () {
    const data = {
        componentConfig: component_1.componentConfig
    };
    if (modifyWebpackChainFunc instanceof Function) {
        yield modifyWebpackChainFunc(chain, webpack, data);
    }
    if (customizeFunc instanceof Function) {
        customizeFunc(chain, webpack, helper_1.META_TYPE);
    }
});
function errorHandling(errorLevel, stats) {
    if (errorLevel === 1 && (stats === null || stats === void 0 ? void 0 : stats.hasErrors())) {
        process.exit(1);
    }
}
function build(appPath, config) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const mode = config.mode;
        /** process config.sass options */
        const newConfig = yield (0, chain_1.makeConfig)(config);
        /** initialized chain */
        const webpackChain = (0, build_conf_1.default)(appPath, mode, newConfig);
        /** customized chain */
        yield customizeChain(webpackChain, newConfig.modifyWebpackChain, newConfig.webpackChain);
        if (typeof newConfig.onWebpackChainReady === 'function') {
            newConfig.onWebpackChainReady(webpackChain);
        }
        /** webpack config */
        const errorLevel = typeof config.compiler !== 'string' && ((_a = config.compiler) === null || _a === void 0 ? void 0 : _a.errorLevel) || 0;
        const webpackConfig = webpackChain.toConfig();
        return new Promise((resolve, reject) => {
            if (config.withoutBuild)
                return;
            const compiler = webpack(webpackConfig);
            const onBuildFinish = newConfig.onBuildFinish;
            let prerender;
            const onFinish = function (error, stats) {
                if (typeof onBuildFinish !== 'function')
                    return;
                onBuildFinish({
                    error,
                    stats,
                    isWatch: newConfig.isWatch
                });
            };
            const callback = (err, stats) => __awaiter(this, void 0, void 0, function* () {
                if (err || stats.hasErrors()) {
                    const error = err !== null && err !== void 0 ? err : stats.toJson().errors;
                    (0, logHelper_1.printBuildError)(error);
                    onFinish(error, null);
                    reject(error);
                    errorHandling(errorLevel, stats);
                    return;
                }
                if (!(0, lodash_1.isEmpty)(newConfig.prerender)) {
                    prerender = prerender !== null && prerender !== void 0 ? prerender : new prerender_1.Prerender(newConfig, webpackConfig, stats, config.template.Adapter);
                    yield prerender.render();
                }
                onFinish(null, stats);
                resolve(stats);
            });
            if (newConfig.isWatch) {
                (0, logHelper_1.bindDevLogger)(compiler);
                compiler.watch({
                    aggregateTimeout: 300,
                    poll: undefined
                }, callback);
            }
            else {
                (0, logHelper_1.bindProdLogger)(compiler);
                compiler.run(callback);
            }
        });
    });
}
exports.default = build;
//# sourceMappingURL=index.js.map